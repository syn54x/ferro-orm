{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Ferro is a high-performance, asynchronous ORM for Python, built with a Rust-backed core engine. It combines the ergonomics of Pydantic models with the speed and safety of Rust's SQLx and Sea-Query.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>High-Performance Core: All SQL generation and row hydration are handled by a dedicated Rust engine, minimizing \"Python Tax\" on data-heavy operations.</li> <li>Async First: Built from the ground up for asynchronous applications, utilizing <code>pyo3-async-runtimes</code> for non-blocking I/O.</li> <li>Pydantic Integration: Leverages Pydantic V2 for schema definition and data validation, providing full IDE support and type safety.</li> <li>Zero-Copy Intent: Designed with zero-copy principles to maximize throughput during large-scale data retrieval.</li> <li>Identity Map: Ensures object consistency across your application by tracking active model instances in a thread-safe registry.</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Ferro operates through a dual-layer architecture connected via a high-performance FFI (Foreign Function Interface) bridge:</p> <ol> <li>Python Layer: Developers define models using standard Python classes; a metaclass registers them with the backend.</li> <li>Rust Engine: Built on <code>SQLx</code> and <code>Sea-Query</code> for GIL-free row parsing and object instantiation.</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>Ferro is distributed as pre-compiled wheels for macOS, Linux, and Windows.</p> <pre><code>pip install ferro-orm\n# Or with migration support\npip install \"ferro-orm[alembic]\"\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\nfrom typing import Annotated\nfrom ferro import Model, FerroField, connect\n\nclass User(Model):\n    id: Annotated[int, FerroField(primary_key=True)]\n    username: str\n    is_active: bool = True\n\nasync def main():\n    await connect(\"sqlite:example.db?mode=rwc\", auto_migrate=True)\n\n    # Create\n    alice = await User.create(username=\"alice\")\n\n    # Query\n    active_users = await User.where(User.is_active == True).all()\n    print(f\"Found {len(active_users)} active users.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This section provides an automated technical reference for Ferro's public classes and functions. Documentation is pulled directly from source docstrings.</p> <p>Use the API subsection pages in the navigation:</p> <ul> <li>Core Models</li> <li>Query Builder</li> <li>Field Metadata</li> <li>Global Functions</li> </ul>"},{"location":"connection/","title":"Connection","text":"<p>Ferro requires an explicit connection to a database before any operations can be performed. Connectivity is managed by the high-performance Rust core using <code>SQLx</code>.</p>"},{"location":"connection/#establishing-a-connection","title":"Establishing a Connection","text":"<p>Use the <code>ferro.connect()</code> function to initialize the database engine. This is an asynchronous operation and must be awaited.</p> <pre><code>import ferro\n\nasync def main():\n    await ferro.connect(\"sqlite:example.db?mode=rwc\")\n</code></pre>"},{"location":"connection/#connection-strings","title":"Connection Strings","text":"<p>Ferro supports SQLite, Postgres, and MySQL. The connection string format follows standard URL patterns:</p> Database Connection String Example SQLite <code>sqlite:path/to/database.db</code> or <code>sqlite::memory:</code> Postgres <code>postgres://user:password@localhost:5432/dbname</code> MySQL <code>mysql://user:password@localhost:3306/dbname</code>"},{"location":"connection/#sqlite-notes","title":"SQLite Notes","text":"<p>For SQLite, it is recommended to include <code>?mode=rwc</code> (Read/Write/Create) to ensure the database file is created if it does not exist.</p>"},{"location":"connection/#automatic-migrations-dev-mode","title":"Automatic Migrations (Dev Mode)","text":"<p>During development, you can use the <code>auto_migrate=True</code> flag to automatically align the database schema with your Python models upon connection.</p> <pre><code>await ferro.connect(\"sqlite:example.db?mode=rwc\", auto_migrate=True)\n</code></pre> <p>Production Warning</p> <p><code>auto_migrate=True</code> is intended for development only. For production environments, you should use Alembic for explicit schema versioning and migrations. See the Migrations section for details.</p>"},{"location":"connection/#manual-table-creation","title":"Manual Table Creation","text":"<p>If you prefer to trigger table creation manually (without using <code>auto_migrate</code> during connect), you can use the <code>create_tables()</code> function:</p> <pre><code>await ferro.connect(\"sqlite::memory:\")\n# ... define or import models ...\nawait ferro.create_tables()\n</code></pre>"},{"location":"contributing/","title":"Contributing to Ferro","text":"<p>We welcome contributions to Ferro! This guide will help you get started with developing Ferro locally.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.13+: Ferro requires Python 3.13 or later</li> <li>Rust toolchain: Required for building the Rust core   <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></li> <li>UV: Fast Python package manager   <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/syn54x/ferro-orm.git\ncd ferro-orm\n</code></pre>"},{"location":"contributing/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code>uv sync --group dev\n</code></pre> <p>This will install all development dependencies including: - Testing tools (pytest, pytest-asyncio, pytest-cov) - Linting and formatting tools (ruff, prek) - Build tools (maturin) - Documentation tools (mkdocs-material) - Release tools (commitizen, python-semantic-release)</p>"},{"location":"contributing/#3-install-pre-commit-hooks","title":"3. Install Pre-commit Hooks","text":"<pre><code># Install all hooks (file checks, linting, formatting)\nuv run prek install\n\n# Install commit message validation hook\nuv run prek install --hook-type commit-msg\n</code></pre> <p>These hooks will automatically: - Check for trailing whitespace - Fix end-of-file issues - Validate YAML, TOML, and JSON files - Format Python code with Ruff - Format Rust code with rustfmt - Lint Rust code with clippy - Validate conventional commit messages</p>"},{"location":"contributing/#4-build-the-rust-extension","title":"4. Build the Rust Extension","text":"<pre><code>uv run maturin develop\n</code></pre> <p>This compiles the Rust core and installs it in development mode. You'll need to re-run this command after making changes to Rust code.</p>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests with coverage\nuv run pytest\n\n# Run specific test file\nuv run pytest tests/test_models.py\n\n# Run with verbose output\nuv run pytest -v\n\n# Run tests and generate coverage report\nuv run pytest --cov=src --cov-report=html\n</code></pre>"},{"location":"contributing/#running-linters","title":"Running Linters","text":"<pre><code># Run all pre-commit hooks\nuv run prek run --all-files\n\n# Run specific hooks\nuv run ruff check .        # Python linting\nuv run ruff format .       # Python formatting\ncargo fmt                  # Rust formatting\ncargo clippy               # Rust linting\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve documentation locally (with live reload)\nuv run mkdocs serve\n\n# Build documentation\nuv run mkdocs build\n\n# Documentation will be available at http://127.0.0.1:8000/\n</code></pre>"},{"location":"contributing/#testing-your-changes","title":"Testing Your Changes","text":"<p>Before submitting a PR, ensure:</p> <ol> <li> <p>All tests pass: <pre><code>uv run pytest\n</code></pre></p> </li> <li> <p>All linters pass: <pre><code>uv run prek run --all-files\n</code></pre></p> </li> <li> <p>Rust tests pass: <pre><code>cargo test\n</code></pre></p> </li> <li> <p>Code builds successfully: <pre><code>uv run maturin develop\n</code></pre></p> </li> </ol>"},{"location":"contributing/#conventional-commits","title":"Conventional Commits","text":"<p>Ferro uses Conventional Commits for automated version bumping and changelog generation. All commit messages must follow this format:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"contributing/#commit-types","title":"Commit Types","text":"<ul> <li>feat: New feature (triggers minor version bump)</li> <li>fix: Bug fix (triggers patch version bump)</li> <li>docs: Documentation changes only</li> <li>refactor: Code refactoring (no functional changes)</li> <li>test: Adding or updating tests</li> <li>perf: Performance improvements (triggers patch version bump)</li> <li>build: Build system changes</li> <li>ci: CI/CD configuration changes</li> <li>chore: Other changes that don't modify src or test files</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<pre><code># Feature commits\ngit commit -m \"feat: add support for many-to-many relations\"\ngit commit -m \"feat(queries): implement OR operator for filters\"\n\n# Bug fix commits\ngit commit -m \"fix: resolve connection pool deadlock\"\ngit commit -m \"fix(migrations): handle nullable foreign keys correctly\"\n\n# Documentation commits\ngit commit -m \"docs: update installation instructions\"\ngit commit -m \"docs(api): add examples for transaction usage\"\n\n# Breaking changes (triggers major version bump)\ngit commit -m \"feat!: change Model.create() to require explicit save()\"\n# OR\ngit commit -m \"feat: redesign query API\n\nBREAKING CHANGE: Query.filter() now requires Q objects instead of kwargs\"\n</code></pre>"},{"location":"contributing/#commit-validation","title":"Commit Validation","text":"<p>The pre-commit hook will automatically validate your commit message format. Invalid commits will be rejected with an error message.</p> <p>If you need to bypass the hook (not recommended), use: <pre><code>git commit --no-verify -m \"message\"\n</code></pre></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a feature branch: <pre><code>git checkout -b feat/my-new-feature\n</code></pre></p> </li> <li> <p>Make your changes and commit: <pre><code>git add .\ngit commit -m \"feat: add my new feature\"\n</code></pre></p> </li> <li> <p>Push to your fork: <pre><code>git push origin feat/my-new-feature\n</code></pre></p> </li> <li> <p>Open a Pull Request on GitHub</p> </li> <li> <p>Wait for CI checks to pass:</p> </li> <li>All linters must pass</li> <li>All tests must pass</li> <li> <p>Code must build on all platforms</p> </li> <li> <p>Address review feedback if any</p> </li> <li> <p>Merge once approved!</p> </li> </ol>"},{"location":"contributing/#pr-requirements","title":"PR Requirements","text":"<ul> <li>\u2705 All CI checks pass</li> <li>\u2705 Conventional commit format followed</li> <li>\u2705 Tests added for new features</li> <li>\u2705 Documentation updated</li> <li>\u2705 No merge conflicts with main</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Ferro uses automated releases. You don't need to manually bump versions or update the changelog.</p>"},{"location":"contributing/#how-releases-work","title":"How Releases Work","text":"<ol> <li>Commits are merged to main</li> <li> <p>Changelog is automatically updated with unreleased changes</p> </li> <li> <p>Maintainer triggers the release workflow</p> </li> </ol> <p>The release process is fully automated. To trigger a new release:</p> <ul> <li>Via GitHub CLI (Recommended): <pre><code>gh workflow run release.yml\n</code></pre></li> <li>Via GitHub Web UI: Go to the Actions tab, select the Release workflow, and click Run workflow.</li> </ul> <p>This will:    - Automatically determine the next version from conventional commits.    - Update <code>pyproject.toml</code> and <code>Cargo.toml</code>.    - Finalize <code>CHANGELOG.md</code>.    - Create and push the Git tag.    - Trigger the Build &amp; Publish workflow to upload wheels to PyPI.</p> <ol> <li>Package is automatically published to PyPI</li> <li>Cross-platform wheels are built</li> <li>Package is uploaded using trusted publishing</li> </ol>"},{"location":"contributing/#version-bumping","title":"Version Bumping","text":"<p>Version bumps are determined by commit types:</p> <ul> <li>Major (1.0.0 \u2192 2.0.0): Commits with <code>BREAKING CHANGE:</code> in body or <code>!</code> after type</li> <li>Minor (1.0.0 \u2192 1.1.0): Commits with <code>feat:</code> type</li> <li>Patch (1.0.0 \u2192 1.0.1): Commits with <code>fix:</code> or <code>perf:</code> type</li> </ul>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python","title":"Python","text":"<ul> <li>Follow PEP 8 style guide</li> <li>Use type hints for all functions</li> <li>Maximum line length: 100 characters (enforced by Ruff)</li> <li>Use Pydantic for data validation</li> <li>Write docstrings for all public APIs</li> </ul>"},{"location":"contributing/#rust","title":"Rust","text":"<ul> <li>Follow Rust style guidelines (enforced by rustfmt)</li> <li>Use <code>cargo clippy</code> warnings as errors</li> <li>Write documentation for public APIs</li> <li>Use descriptive variable names</li> <li>Prefer explicit types over inference in function signatures</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#python-tests","title":"Python Tests","text":"<p>Located in <code>tests/</code> directory. Use pytest with async support:</p> <pre><code>import pytest\nfrom ferro import Model, FerroField, connect\n\n@pytest.mark.asyncio\nasync def test_create_model():\n    await connect(\"sqlite::memory:\")\n    user = await User.create(name=\"Alice\")\n    assert user.name == \"Alice\"\n</code></pre>"},{"location":"contributing/#rust-tests","title":"Rust Tests","text":"<p>Located alongside Rust code with <code>#[cfg(test)]</code>:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sql_generation() {\n        let query = generate_select_query(\"users\");\n        assert_eq!(query, \"SELECT * FROM users\");\n    }\n}\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>ferro/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 ferro/           # Python package\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 queries.py\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 lib.rs           # Rust core\n\u251c\u2500\u2500 tests/               # Python tests\n\u251c\u2500\u2500 docs/                # Documentation\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/       # CI/CD workflows\n\u251c\u2500\u2500 Cargo.toml           # Rust dependencies\n\u251c\u2500\u2500 pyproject.toml       # Python dependencies\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: https://syn54x.github.io/ferro-orm</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Ferro, you agree that your contributions will be licensed under the same license as the project (Apache 2.0 OR MIT).</p>"},{"location":"fields/","title":"Fields","text":"<p>Ferro supports a wide range of Python types, automatically mapping them to the most efficient database types available in the Rust engine.</p>"},{"location":"fields/#supported-types","title":"Supported Types","text":"Python Type Database Type (General) Notes <code>int</code> <code>INTEGER</code> <code>str</code> <code>TEXT</code> / <code>VARCHAR</code> <code>bool</code> <code>BOOLEAN</code> / <code>INTEGER</code> Stored as 0/1 in SQLite. <code>float</code> <code>DOUBLE</code> / <code>FLOAT</code> <code>datetime</code> <code>DATETIME</code> / <code>TIMESTAMP</code> Use <code>datetime.datetime</code> with timezone awareness. <code>date</code> <code>DATE</code> Use <code>datetime.date</code>. <code>UUID</code> <code>UUID</code> / <code>TEXT</code> Stored as a 36-character string if native UUID is unavailable. <code>Decimal</code> <code>NUMERIC</code> / <code>DECIMAL</code> Use <code>decimal.Decimal</code> for high-precision financial data. <code>bytes</code> <code>BLOB</code> / <code>BYTEA</code> Stored as binary data. <code>Enum</code> <code>ENUM</code> / <code>TEXT</code> Python <code>enum.Enum</code> (typically string-backed). <code>dict</code> / <code>list</code> <code>JSON</code> / <code>JSONB</code> Stored as JSON strings in SQLite."},{"location":"fields/#ferrofield-metadata","title":"FerroField Metadata","text":"<p>To configure database-level constraints and behaviors, use the <code>FerroField</code> metadata container. The preferred way to apply this is via <code>typing.Annotated</code>.</p> <pre><code>from typing import Annotated\nfrom ferro import Model, FerroField\n\nclass Product(Model):\n    sku: Annotated[str, FerroField(primary_key=True)]\n    slug: Annotated[str, FerroField(unique=True, index=True)]\n    price: Annotated[Decimal, FerroField(index=True)]\n</code></pre>"},{"location":"fields/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>primary_key</code> <code>bool</code> <code>False</code> Marks the field as the primary key for the table. <code>autoincrement</code> <code>bool \\| None</code> <code>None</code> If <code>True</code>, the database generates values automatically. Defaults to <code>True</code> for integer primary keys. <code>unique</code> <code>bool</code> <code>False</code> Enforces a uniqueness constraint on the column. <code>index</code> <code>bool</code> <code>False</code> Creates a database index for this column to improve query performance."},{"location":"fields/#pydantic-integration","title":"Pydantic Integration","text":"<p>Since Ferro is built on Pydantic, all standard Pydantic validation and field configuration still apply.</p> <pre><code>from pydantic import Field\nfrom ferro import Model, FerroField\n\nclass User(Model):\n    # Combine Ferro metadata with Pydantic validation\n    username: Annotated[\n        str,\n        FerroField(unique=True),\n        Field(min_length=3, max_length=50)\n    ]\n</code></pre>"},{"location":"migrations/","title":"Migrations","text":"<p>Ferro integrates with Alembic, the industry-standard migration tool for Python, to provide robust and reliable schema management.</p>"},{"location":"migrations/#integration-overview","title":"Integration Overview","text":"<p>Instead of reinventing a migration system, Ferro utilizes a SQLAlchemy bridge. This bridge translates Ferro's internal model registry into an in-memory SQLAlchemy <code>MetaData</code> object, which Alembic then uses to detect changes.</p>"},{"location":"migrations/#installation","title":"Installation","text":"<p>Ensure you have installed the migration dependencies:</p> <pre><code>pip install \"ferro-orm[alembic]\"\n</code></pre>"},{"location":"migrations/#using-get_metadata","title":"Using <code>get_metadata()</code>","text":"<p>To connect Ferro to Alembic, you must update your <code>env.py</code> file (typically found in the <code>migrations/</code> directory created by <code>alembic init</code>).</p> <p>The <code>get_metadata()</code> function automatically discovers all registered Ferro models and returns a SQLAlchemy <code>MetaData</code> object.</p> <pre><code># migrations/env.py\nfrom ferro.migrations import get_metadata\nfrom my_app.models import User, Post  # Ensure models are imported to register them\n\n# Pass the Ferro-generated metadata to Alembic\ntarget_metadata = get_metadata()\n</code></pre>"},{"location":"migrations/#workflow","title":"Workflow","text":"<ol> <li>Initialize Alembic: Run <code>alembic init migrations</code> if you haven't already.</li> <li>Define Models: Create your Ferro models as usual.</li> <li>Generate Migration: Run the autogenerate command:     <pre><code>alembic revision --autogenerate -m \"Initial schema\"\n</code></pre></li> <li>Apply Migration: Update your database:     <pre><code>alembic upgrade head\n</code></pre></li> </ol>"},{"location":"migrations/#precision-mapping","title":"Precision Mapping","text":"<p>Ferro's migration bridge ensures high fidelity between your code and the database:</p> <ul> <li>Nullability: Automatically detects whether a field is required or optional (e.g., <code>str</code> vs <code>str | None</code>).</li> <li>Complex Types: Correctly maps Enums, Decimals, UUIDs, and JSON fields to the appropriate database-native types.</li> <li>Constraints: Translates <code>primary_key</code>, <code>unique</code>, and <code>index</code> metadata directly into the migration script.</li> <li>Foreign Keys: Automatically generates <code>FOREIGN KEY</code> constraints, including custom <code>on_delete</code> behaviors like <code>CASCADE</code> or <code>SET NULL</code>.</li> <li>Join Tables: Automatically discovers and includes hidden join tables for Many-to-Many relationships.</li> </ul>"},{"location":"models/","title":"Models","text":"<p>Models are the central building blocks of Ferro. They define your data schema in Python and are automatically mapped to database tables by the Rust engine.</p>"},{"location":"models/#defining-a-model","title":"Defining a Model","text":"<p>To create a model, inherit from <code>ferro.Model</code>. Models use standard Python type hints, leveraging Pydantic V2 for validation and serialization.</p> <pre><code>from typing import Annotated\nfrom ferro import Model, FerroField\n\nclass User(Model):\n    id: Annotated[int, FerroField(primary_key=True)]\n    username: str\n    is_active: bool = True\n</code></pre>"},{"location":"models/#internal-mechanics","title":"Internal Mechanics","text":"<p>Ferro uses a custom <code>ModelMetaclass</code> to bridge the gap between Python and Rust:</p> <ol> <li>Schema Capture: When you define a class, the metaclass inspects its fields and constraints.</li> <li>Rust Registration: The schema is serialized to a JSON-AST and passed to the Rust core's <code>MODEL_REGISTRY</code>.</li> <li>Table Generation: When <code>auto_migrate=True</code> is used or <code>create_tables()</code> is called, the Rust engine generates the appropriate SQL <code>CREATE TABLE</code> statements.</li> </ol>"},{"location":"models/#model-configuration","title":"Model Configuration","text":"<p>Since Ferro models are Pydantic models, you can use the <code>model_config</code> attribute to control standard behaviors.</p> <pre><code>from pydantic import ConfigDict\nfrom ferro import Model\n\nclass Product(Model):\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n        validate_assignment=True\n    )\n\n    sku: str\n    name: str\n</code></pre>"},{"location":"models/#the-identity-map","title":"The Identity Map","text":"<p>Ferro implements an Identity Map pattern to ensure object consistency within a single application process.</p> <ul> <li>Consistency: If you fetch the same record twice (e.g., once via <code>User.get(1)</code> and again via a query), Ferro returns the exact same Python object instance.</li> <li>Performance: Returning existing instances from the identity map bypasses the hydration cost of creating new Python objects.</li> <li>In-Place Updates: Changes made to an object are immediately visible to all other parts of your code holding a reference to that same object.</li> </ul> <p>To manually remove an object from the identity map (forcing a fresh database fetch on the next request), use <code>ferro.evict_instance(model_name, pk)</code>.</p>"},{"location":"queries/","title":"Queries","text":"<p>Ferro provides a fluent, type-safe API for constructing and executing database queries. All queries are constructed in Python and executed by the high-performance Rust engine.</p>"},{"location":"queries/#fetching-data","title":"Fetching Data","text":"<p>Queries are typically started using the <code>select()</code> or <code>where()</code> methods on a Model class.</p>"},{"location":"queries/#basic-filtering","title":"Basic Filtering","text":"<p>Use standard Python comparison operators on Model fields to create filter conditions.</p> <pre><code># Select all active users\nusers = await User.where(User.is_active == True).all()\n\n# Select users with age &gt;= 18\nadults = await User.where(User.age &gt;= 18).all()\n</code></pre>"},{"location":"queries/#chaining","title":"Chaining","text":"<p>Methods can be chained to build complex queries incrementally.</p> <pre><code>results = await Product.select() \\\n    .where(Product.category == \"Electronics\") \\\n    .order_by(Product.price, \"desc\") \\\n    .limit(10) \\\n    .offset(5) \\\n    .all()\n</code></pre>"},{"location":"queries/#logical-operators","title":"Logical Operators","text":"<p>Use bitwise operators for complex logical conditions. Note that parentheses are required around each condition.</p> <ul> <li>AND: <code>&amp;</code></li> <li>OR: <code>|</code></li> </ul> <pre><code># (age &gt; 21 AND status == 'active') OR role == 'admin'\nquery = User.where(\n    ((User.age &gt; 21) &amp; (User.status == \"active\")) | (User.role == \"admin\")\n)\n</code></pre>"},{"location":"queries/#terminal-operations","title":"Terminal Operations","text":"<p>These methods execute the query and return a result.</p> Method Return Type Description <code>.all()</code> <code>list[Model]</code> Executes the query and returns all matching records. <code>.first()</code> <code>Model \\| None</code> Returns the first matching record or <code>None</code>. <code>.count()</code> <code>int</code> Returns the total number of matching records. <code>.exists()</code> <code>bool</code> Returns <code>True</code> if at least one matching record exists."},{"location":"queries/#mutations","title":"Mutations","text":"<p>Ferro supports both instance-level and batch mutation operations.</p>"},{"location":"queries/#creating-records","title":"Creating Records","text":"<pre><code># Single record\nuser = await User.create(username=\"alice\", email=\"alice@example.com\")\n\n# Bulk creation (highly efficient)\nusers = [User(username=f\"user_{i}\") for i in range(100)]\nawait User.bulk_create(users)\n</code></pre>"},{"location":"queries/#updating-records","title":"Updating Records","text":"<p>Batch updates can be performed directly on a query without loading instances into memory.</p> <pre><code># Update all products in a category\nawait Product.where(Product.category == \"Old\").update(status=\"archived\")\n</code></pre>"},{"location":"queries/#deleting-records","title":"Deleting Records","text":"<pre><code># Delete specific instance\nawait user.delete()\n\n# Batch deletion\nawait User.where(User.is_active == False).delete()\n</code></pre>"},{"location":"queries/#sql-injection-protection","title":"SQL Injection Protection","text":"<p>All values passed to the fluent API (via <code>.where()</code>, <code>.update()</code>, etc.) are automatically parameterized by the Rust engine. Raw user input is never concatenated into SQL strings, ensuring built-in protection against SQL injection attacks.</p>"},{"location":"relations/","title":"Relations","text":"<p>Ferro provides a robust system for connecting models, supporting standard relational patterns with zero-boilerplate reverse lookups and automated join table management.</p>"},{"location":"relations/#one-to-many","title":"One-to-Many","text":"<p>The most common relationship type. It is defined using a <code>ForeignKey</code> on the \"child\" model and a <code>BackRelationship</code> marker on the \"parent\" model.</p> <pre><code>from typing import Annotated\nfrom ferro import Model, ForeignKey, BackRelationship\n\nclass Author(Model):\n    id: int\n    name: str\n    # Marker for reverse lookup; provides full Query intellisense\n    posts: BackRelationship[\"Post\"] = None\n\nclass Post(Model):\n    id: int\n    title: str\n    # Defines the forward link and the name of the reverse field\n    author: Annotated[Author, ForeignKey(related_name=\"posts\")]\n</code></pre>"},{"location":"relations/#shadow-fields","title":"Shadow Fields","text":"<p>For every <code>ForeignKey</code> field (e.g., <code>author</code>), Ferro automatically creates a \"shadow\" ID column in the database (e.g., <code>author_id</code>). You can access or filter by this field directly via <code>post.author_id</code>.</p>"},{"location":"relations/#one-to-one","title":"One-to-One","text":"<p>A strict 1:1 link is created by adding <code>unique=True</code> to a <code>ForeignKey</code>.</p> <pre><code>class Profile(Model):\n    user: Annotated[User, ForeignKey(related_name=\"profile\", unique=True)]\n</code></pre> <p>Behavioral Difference:</p> <ul> <li>Forward: Accessing <code>await profile.user</code> returns a single <code>User</code> object.</li> <li>Reverse: Accessing <code>await user.profile</code> returns a single <code>Profile</code> object (internally calls <code>.first()</code>) instead of a <code>Query</code> object.</li> </ul>"},{"location":"relations/#many-to-many","title":"Many-to-Many","text":"<p>Defined using the <code>ManyToManyField</code>. Ferro automatically manages the hidden join table required for this relationship.</p> <pre><code>from ferro import ManyToManyField\n\nclass Student(Model):\n    name: str\n    courses: Annotated[list[\"Course\"], ManyToManyField(related_name=\"students\")] = None\n\nclass Course(Model):\n    title: str\n    students: BackRelationship[\"Student\"] = None\n</code></pre>"},{"location":"relations/#join-table-management","title":"Join Table Management","text":"<p>The Rust engine automatically registers and creates a join table (e.g., <code>student_courses</code>) when the models are initialized. You do not need to define a \"through\" model manually unless you need custom fields on the link.</p>"},{"location":"relations/#relationship-mutators","title":"Relationship Mutators","text":"<p>Many-to-Many relationships provide specialized methods for managing links:</p> <ul> <li><code>.add(*instances)</code>: Create new links in the join table.</li> <li><code>.remove(*instances)</code>: Remove specific links.</li> <li><code>.clear()</code>: Remove all links for the current instance.</li> </ul> <pre><code>await student.courses.add(math_101, physics_202)\nawait student.courses.clear()\n</code></pre>"},{"location":"relations/#lazy-loading-vs-queries","title":"Lazy Loading vs. Queries","text":"<p>Ferro relations are lazy. Data is never fetched until you explicitly request it.</p> <ol> <li>Forward Relations: Accessing a <code>ForeignKey</code> returns an awaitable descriptor.     <pre><code>author = await post.author  # Database hit\n</code></pre></li> <li>Reverse/M2M Relations: Accessing a <code>BackRelationship</code> or <code>ManyToManyField</code> returns a <code>Query</code> object. This allows you to chain further filters before execution.     <pre><code>posts = await author.posts.where(Post.published == True).all()\n</code></pre></li> </ol>"},{"location":"transactions/","title":"Transactions","text":"<p>Ferro provides a simple and robust way to ensure data integrity through atomic transactions using an asynchronous context manager.</p>"},{"location":"transactions/#usage","title":"Usage","text":"<p>To group multiple database operations into a single atomic unit, use the <code>ferro.transaction()</code> context manager.</p> <pre><code>from ferro import transaction\n\nasync def process_order(user, product):\n    async with transaction():\n        # All operations inside this block are atomic\n        order = await Order.create(user=user, product=product)\n        await user.posts.add(order)\n\n        # If any error occurs here, everything above is rolled back\n        await product.refresh()\n</code></pre>"},{"location":"transactions/#atomicity-and-rollbacks","title":"Atomicity and Rollbacks","text":"<p>When you enter a transaction block:</p> <ol> <li>Automatic Commit: If the block finishes without an exception, Ferro automatically commits all changes to the database.</li> <li>Automatic Rollback: If an exception is raised within the block, Ferro immediately rolls back all operations performed during that transaction, ensuring the database remains in a consistent state.</li> </ol> <pre><code>try:\n    async with transaction():\n        await User.create(username=\"alice\")\n        raise RuntimeError(\"Something went wrong\")\nexcept RuntimeError:\n    # 'alice' was never persisted to the database\n    pass\n</code></pre>"},{"location":"transactions/#connection-affinity","title":"Connection Affinity","text":"<p>Ferro's transaction engine uses Connection Affinity to guarantee correctness:</p> <ul> <li>Shared Connection: All operations performed within a <code>transaction()</code> block are guaranteed to use the same underlying database connection.</li> <li>Task Safety: Connection affinity is managed via <code>contextvars</code>, making it safe to use in highly concurrent asynchronous environments.</li> </ul>"},{"location":"transactions/#manual-control","title":"Manual Control","text":"<p>While the context manager is the recommended way to handle transactions, you can also use the low-level API if you need finer control:</p> Method Description <code>begin_transaction()</code> Manually starts a new transaction and returns a unique <code>tx_id</code>. <code>commit_transaction(tx_id)</code> Commits all changes for the given transaction ID. <code>rollback_transaction(tx_id)</code> Rolls back all changes for the given transaction ID. <p>Note on Nesting</p> <p>Ferro currently supports single-level transactions. Nested <code>async with transaction():</code> calls will participate in the outermost transaction.</p>"},{"location":"api/core-models/","title":"Core Models","text":""},{"location":"api/core-models/#ferro.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Provide the base class for all Ferro models</p> <p>Inheriting from this class registers schema metadata with the Rust core and exposes high-performance CRUD and query entrypoints.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class User(Model):\n...     id: int | None = None\n...     name: str\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model-attributes","title":"Attributes","text":""},{"location":"api/core-models/#ferro.models.Model.model_config","title":"<code>model_config = ConfigDict(from_attributes=True, use_attribute_docstrings=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/core-models/#ferro.models.Model-functions","title":"Functions","text":""},{"location":"api/core-models/#ferro.models.Model.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initialize a model instance and normalize relationship inputs</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>Field values used to construct the model.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = User(name=\"Taylor\")\n&gt;&gt;&gt; isinstance(user, User)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.save","title":"<code>save()</code>  <code>async</code>","text":"<p>Persist the current model instance</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = User(name=\"Taylor\")\n&gt;&gt;&gt; await user.save()\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete the current model instance from storage</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.get(1)\n&gt;&gt;&gt; if user:\n...     await user.delete()\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.all","title":"<code>all()</code>  <code>async</code> <code>classmethod</code>","text":"<p>Fetch all records for this model class</p> <p>Returns:</p> Type Description <code>list[Self]</code> <p>A list of hydrated model instances.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; users = await User.all()\n&gt;&gt;&gt; isinstance(users, list)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.get","title":"<code>get(pk)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Fetch one record by primary key value</p> <p>Parameters:</p> Name Type Description Default <code>pk</code> <code>Any</code> <p>Primary key value to fetch a single record.</p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>The matching model instance, or None when no record exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.get(1)\n&gt;&gt;&gt; user is None or isinstance(user, User)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.refresh","title":"<code>refresh()</code>  <code>async</code>","text":"<p>Reload this instance from storage using its primary key</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no primary key is available or the record no longer exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.get(1)\n&gt;&gt;&gt; if user:\n...     await user.refresh()\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.where","title":"<code>where(node)</code>  <code>classmethod</code>","text":"<p>Start a fluent query with an initial condition</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>QueryNode</code> <p>Query predicate node to apply first.</p> required <p>Returns:</p> Type Description <code>Query[Self]</code> <p>A query object scoped to this model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.where(User.id == 1)\n&gt;&gt;&gt; isinstance(query, Query)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.select","title":"<code>select()</code>  <code>classmethod</code>","text":"<p>Start an empty fluent query for this model class</p> <p>Returns:</p> Type Description <code>Query[Self]</code> <p>A query object scoped to this model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.select().limit(5)\n&gt;&gt;&gt; isinstance(query, Query)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.create","title":"<code>create(**fields)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create and persist a new model instance</p> <p>Parameters:</p> Name Type Description Default <code>**fields</code> <p>Field values to construct the model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The newly created and persisted model instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.create(name=\"Taylor\")\n&gt;&gt;&gt; isinstance(user, User)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.bulk_create","title":"<code>bulk_create(instances)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Persist multiple instances in a single bulk operation</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>list[Self]</code> <p>Model instances to persist.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of records inserted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rows = await User.bulk_create([User(name=\"A\"), User(name=\"B\")])\n&gt;&gt;&gt; isinstance(rows, int)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.get_or_create","title":"<code>get_or_create(defaults=None, **fields)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Fetch a record by filters or create one when missing</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>dict[str, Any] | None</code> <p>Values applied only when creating a new record.</p> <code>None</code> <code>**fields</code> <p>Exact-match filters used for lookup.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Self, bool]</code> <p>A tuple of <code>(instance, created)</code> where <code>created</code> is True for new records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user, created = await User.get_or_create(email=\"a@b.com\")\n&gt;&gt;&gt; isinstance(created, bool)\nTrue\n</code></pre>"},{"location":"api/core-models/#ferro.models.Model.update_or_create","title":"<code>update_or_create(defaults=None, **fields)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Update a matched record or create one when missing</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>dict[str, Any] | None</code> <p>Values applied on update or create paths.</p> <code>None</code> <code>**fields</code> <p>Exact-match filters used for lookup.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Self, bool]</code> <p>A tuple of <code>(instance, created)</code> where <code>created</code> is True for new records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user, created = await User.update_or_create(\n...     email=\"a@b.com\",\n...     defaults={\"name\": \"Taylor\"},\n... )\n&gt;&gt;&gt; isinstance(created, bool)\nTrue\n</code></pre>"},{"location":"api/field-metadata/","title":"Field Metadata","text":""},{"location":"api/field-metadata/#ferro.base.FerroField","title":"<code>FerroField</code>","text":"<p>Store database column metadata for a model field</p> <p>Attributes:</p> <pre><code>primary_key: Mark the field as the table primary key.\nautoincrement: Override automatic increment behavior for primary key columns.\nunique: Enforce a uniqueness constraint for the column.\nindex: Request an index for the column.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     email: Annotated[str, FerroField(unique=True, index=True)]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>class FerroField:\n    \"\"\"Store database column metadata for a model field\n\n    Attributes:\n\n        primary_key: Mark the field as the table primary key.\n        autoincrement: Override automatic increment behavior for primary key columns.\n        unique: Enforce a uniqueness constraint for the column.\n        index: Request an index for the column.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class User(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     email: Annotated[str, FerroField(unique=True, index=True)]\n    \"\"\"\n\n    def __init__(\n        self,\n        primary_key: bool = False,\n        autoincrement: bool | None = None,\n        unique: bool = False,\n        index: bool = False,\n    ):\n        \"\"\"Initialize field metadata options\n\n        Args:\n\n            primary_key: Set to True when the field is the primary key.\n            autoincrement: Control whether the database auto-increments the value.\n                When not provided, the backend infers a default for integer primary keys.\n            unique: Set to True to enforce uniqueness.\n            index: Set to True to create a database index.\n\n        Examples:\n            &gt;&gt;&gt; from typing import Annotated\n            &gt;&gt;&gt; from ferro.models import Model\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; class User(Model):\n            ...     id: Annotated[int, FerroField(primary_key=True)]\n            ...     created_at: Annotated[int, FerroField(index=True)]\n        \"\"\"\n        self.primary_key = primary_key\n        self.autoincrement = autoincrement\n        self.unique = unique\n        self.index = index\n</code></pre>"},{"location":"api/field-metadata/#ferro.base.FerroField-attributes","title":"Attributes","text":""},{"location":"api/field-metadata/#ferro.base.FerroField.primary_key","title":"<code>primary_key = primary_key</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.FerroField.autoincrement","title":"<code>autoincrement = autoincrement</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.FerroField.unique","title":"<code>unique = unique</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.FerroField.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.FerroField-functions","title":"Functions","text":""},{"location":"api/field-metadata/#ferro.base.FerroField.__init__","title":"<code>__init__(primary_key=False, autoincrement=None, unique=False, index=False)</code>","text":"<p>Initialize field metadata options</p> <p>Args:</p> <pre><code>primary_key: Set to True when the field is the primary key.\nautoincrement: Control whether the database auto-increments the value.\n    When not provided, the backend infers a default for integer primary keys.\nunique: Set to True to enforce uniqueness.\nindex: Set to True to create a database index.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     created_at: Annotated[int, FerroField(index=True)]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>def __init__(\n    self,\n    primary_key: bool = False,\n    autoincrement: bool | None = None,\n    unique: bool = False,\n    index: bool = False,\n):\n    \"\"\"Initialize field metadata options\n\n    Args:\n\n        primary_key: Set to True when the field is the primary key.\n        autoincrement: Control whether the database auto-increments the value.\n            When not provided, the backend infers a default for integer primary keys.\n        unique: Set to True to enforce uniqueness.\n        index: Set to True to create a database index.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class User(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     created_at: Annotated[int, FerroField(index=True)]\n    \"\"\"\n    self.primary_key = primary_key\n    self.autoincrement = autoincrement\n    self.unique = unique\n    self.index = index\n</code></pre>"},{"location":"api/field-metadata/#ferro.base.ForeignKey","title":"<code>ForeignKey</code>","text":"<p>Describe a forward foreign-key relationship between models</p> <p>Attributes:</p> <pre><code>to: Target model class resolved during model binding.\nrelated_name: Name of the reverse relationship attribute on the target model.\non_delete: Referential action applied when the parent row is deleted.\nunique: Treat the relation as one-to-one when True.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Post(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     author: Annotated[int, ForeignKey(\"posts\", on_delete=\"CASCADE\")]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>class ForeignKey:\n    \"\"\"Describe a forward foreign-key relationship between models\n\n    Attributes:\n\n        to: Target model class resolved during model binding.\n        related_name: Name of the reverse relationship attribute on the target model.\n        on_delete: Referential action applied when the parent row is deleted.\n        unique: Treat the relation as one-to-one when True.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class User(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Post(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     author: Annotated[int, ForeignKey(\"posts\", on_delete=\"CASCADE\")]\n    \"\"\"\n\n    def __init__(\n        self, related_name: str, on_delete: str = \"CASCADE\", unique: bool = False\n    ):\n        \"\"\"Initialize foreign-key relationship metadata\n\n        Args:\n\n            related_name: Name for reverse access from the related model.\n            on_delete: Referential action for parent deletion.\n                Common values include \"CASCADE\", \"RESTRICT\", \"SET NULL\", \"SET DEFAULT\", and \"NO ACTION\".\n            unique: Set to True to enforce one-to-one behavior.\n\n        Examples:\n            &gt;&gt;&gt; from typing import Annotated\n            &gt;&gt;&gt; from ferro.models import Model\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; class User(Model):\n            ...     id: Annotated[int, FerroField(primary_key=True)]\n            ...     profile_id: Annotated[int, ForeignKey(\"user\", unique=True)]\n        \"\"\"\n        self.to = None  # Resolved later\n        self.related_name = related_name\n        self.on_delete = on_delete\n        self.unique = unique\n</code></pre>"},{"location":"api/field-metadata/#ferro.base.ForeignKey-attributes","title":"Attributes","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey.to","title":"<code>to = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey.related_name","title":"<code>related_name = related_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey.on_delete","title":"<code>on_delete = on_delete</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey.unique","title":"<code>unique = unique</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey-functions","title":"Functions","text":""},{"location":"api/field-metadata/#ferro.base.ForeignKey.__init__","title":"<code>__init__(related_name, on_delete='CASCADE', unique=False)</code>","text":"<p>Initialize foreign-key relationship metadata</p> <p>Args:</p> <pre><code>related_name: Name for reverse access from the related model.\non_delete: Referential action for parent deletion.\n    Common values include \"CASCADE\", \"RESTRICT\", \"SET NULL\", \"SET DEFAULT\", and \"NO ACTION\".\nunique: Set to True to enforce one-to-one behavior.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     profile_id: Annotated[int, ForeignKey(\"user\", unique=True)]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>def __init__(\n    self, related_name: str, on_delete: str = \"CASCADE\", unique: bool = False\n):\n    \"\"\"Initialize foreign-key relationship metadata\n\n    Args:\n\n        related_name: Name for reverse access from the related model.\n        on_delete: Referential action for parent deletion.\n            Common values include \"CASCADE\", \"RESTRICT\", \"SET NULL\", \"SET DEFAULT\", and \"NO ACTION\".\n        unique: Set to True to enforce one-to-one behavior.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class User(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     profile_id: Annotated[int, ForeignKey(\"user\", unique=True)]\n    \"\"\"\n    self.to = None  # Resolved later\n    self.related_name = related_name\n    self.on_delete = on_delete\n    self.unique = unique\n</code></pre>"},{"location":"api/field-metadata/#ferro.base.ManyToManyField","title":"<code>ManyToManyField</code>","text":"<p>Describe metadata for a many-to-many relationship</p> <p>Attributes:</p> <pre><code>to: Target model class resolved during model binding.\nrelated_name: Name of the reverse relationship attribute on the target model.\nthrough: Optional join table name used for the association.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Tag(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Post(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     tags: Annotated[list[int], ManyToManyField(\"posts\")]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>class ManyToManyField:\n    \"\"\"Describe metadata for a many-to-many relationship\n\n    Attributes:\n\n        to: Target model class resolved during model binding.\n        related_name: Name of the reverse relationship attribute on the target model.\n        through: Optional join table name used for the association.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Tag(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Post(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     tags: Annotated[list[int], ManyToManyField(\"posts\")]\n    \"\"\"\n\n    def __init__(self, related_name: str, through: str | None = None):\n        \"\"\"Initialize many-to-many relationship metadata\n\n        Args:\n\n            related_name: Name for reverse access from the related model.\n            through: Explicit join table name.\n                When omitted, Ferro generates a join table name automatically.\n\n        Examples:\n            &gt;&gt;&gt; from typing import Annotated\n            &gt;&gt;&gt; from ferro.models import Model\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; class User(Model):\n            ...     id: Annotated[int, FerroField(primary_key=True)]\n            ...     teams: Annotated[list[int], ManyToManyField(\"members\", through=\"team_members\")]\n        \"\"\"\n        self.to = None  # Resolved later\n        self.related_name = related_name\n        self.through = through\n</code></pre>"},{"location":"api/field-metadata/#ferro.base.ManyToManyField-attributes","title":"Attributes","text":""},{"location":"api/field-metadata/#ferro.base.ManyToManyField.to","title":"<code>to = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ManyToManyField.related_name","title":"<code>related_name = related_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ManyToManyField.through","title":"<code>through = through</code>  <code>instance-attribute</code>","text":""},{"location":"api/field-metadata/#ferro.base.ManyToManyField-functions","title":"Functions","text":""},{"location":"api/field-metadata/#ferro.base.ManyToManyField.__init__","title":"<code>__init__(related_name, through=None)</code>","text":"<p>Initialize many-to-many relationship metadata</p> <p>Args:</p> <pre><code>related_name: Name for reverse access from the related model.\nthrough: Explicit join table name.\n    When omitted, Ferro generates a join table name automatically.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Annotated\n&gt;&gt;&gt; from ferro.models import Model\n&gt;&gt;&gt;\n&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     teams: Annotated[list[int], ManyToManyField(\"members\", through=\"team_members\")]\n</code></pre> Source code in <code>src/ferro/base.py</code> <pre><code>def __init__(self, related_name: str, through: str | None = None):\n    \"\"\"Initialize many-to-many relationship metadata\n\n    Args:\n\n        related_name: Name for reverse access from the related model.\n        through: Explicit join table name.\n            When omitted, Ferro generates a join table name automatically.\n\n    Examples:\n        &gt;&gt;&gt; from typing import Annotated\n        &gt;&gt;&gt; from ferro.models import Model\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class User(Model):\n        ...     id: Annotated[int, FerroField(primary_key=True)]\n        ...     teams: Annotated[list[int], ManyToManyField(\"members\", through=\"team_members\")]\n    \"\"\"\n    self.to = None  # Resolved later\n    self.related_name = related_name\n    self.through = through\n</code></pre>"},{"location":"api/global-functions/","title":"Global Functions","text":""},{"location":"api/global-functions/#ferro.connect","title":"<code>connect(url, auto_migrate=False)</code>  <code>async</code>","text":"<p>Establish a connection to the database.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The database connection string (e.g., \"sqlite:example.db?mode=rwc\").</p> required <code>auto_migrate</code> <code>bool</code> <p>If True, automatically create tables for all registered models.</p> <code>False</code> Source code in <code>src/ferro/__init__.py</code> <pre><code>async def connect(url: str, auto_migrate: bool = False) -&gt; None:\n    \"\"\"\n    Establish a connection to the database.\n\n    Args:\n        url: The database connection string (e.g., \"sqlite:example.db?mode=rwc\").\n        auto_migrate: If True, automatically create tables for all registered models.\n    \"\"\"\n    from .relations import resolve_relationships\n\n    resolve_relationships()\n\n    await _core_connect(url)\n    if auto_migrate:\n        await create_tables()\n</code></pre>"},{"location":"api/global-functions/#ferro.models.transaction","title":"<code>transaction()</code>  <code>async</code>","text":"<p>Run database operations inside a transaction context</p> <p>Yields control to the caller within an open transaction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async with transaction():\n...     user = await User.create(name=\"Taylor\")\n...     await user.save()\n</code></pre> Source code in <code>src/ferro/models.py</code> <pre><code>@asynccontextmanager\nasync def transaction():\n    \"\"\"Run database operations inside a transaction context\n\n    Yields control to the caller within an open transaction.\n\n    Examples:\n        &gt;&gt;&gt; async with transaction():\n        ...     user = await User.create(name=\"Taylor\")\n        ...     await user.save()\n    \"\"\"\n    tx_id = await begin_transaction()\n    token = _CURRENT_TRANSACTION.set(tx_id)\n    try:\n        yield\n        await commit_transaction(tx_id)\n    except Exception:\n        await rollback_transaction(tx_id)\n        raise\n    finally:\n        _CURRENT_TRANSACTION.reset(token)\n</code></pre>"},{"location":"api/global-functions/#ferro.create_tables","title":"<code>create_tables()</code>  <code>builtin</code>","text":"<p>Manually triggers table creation for all registered models.</p> <p>Returns an awaitable object (Python coroutine).</p>"},{"location":"api/global-functions/#ferro.create_tables--errors","title":"Errors","text":"<p>Returns a <code>PyErr</code> if the engine is not initialized or if SQL execution fails.</p>"},{"location":"api/global-functions/#ferro.reset_engine","title":"<code>reset_engine()</code>  <code>builtin</code>","text":"<p>Shuts down the global engine and clears the Identity Map.</p> <p>This is useful for testing environments to ensure isolation between test runs.</p>"},{"location":"api/global-functions/#ferro.reset_engine--errors","title":"Errors","text":"<p>Returns a <code>PyErr</code> if the engine lock cannot be acquired.</p>"},{"location":"api/global-functions/#ferro.evict_instance","title":"<code>evict_instance(name, pk)</code>  <code>builtin</code>","text":"<p>Evicts a specific model instance from the global Identity Map.</p>"},{"location":"api/query-builder/","title":"Query Builder","text":""},{"location":"api/query-builder/#ferro.query.builder.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Build and execute fluent ORM queries.</p> <p>Attributes:</p> Name Type Description <code>model_cls</code> <p>Model class used to hydrate results.</p> <code>where_clause</code> <code>list[QueryNode]</code> <p>Accumulated filter nodes for the query.</p> <code>order_by_clause</code> <code>list[dict[str, str]]</code> <p>Sort definitions sent to the Rust core.</p>"},{"location":"api/query-builder/#ferro.query.builder.Query-attributes","title":"Attributes","text":""},{"location":"api/query-builder/#ferro.query.builder.Query.model_cls","title":"<code>model_cls = model_cls</code>  <code>instance-attribute</code>","text":""},{"location":"api/query-builder/#ferro.query.builder.Query.where_clause","title":"<code>where_clause = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/query-builder/#ferro.query.builder.Query.order_by_clause","title":"<code>order_by_clause = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/query-builder/#ferro.query.builder.Query-functions","title":"Functions","text":""},{"location":"api/query-builder/#ferro.query.builder.Query.__init__","title":"<code>__init__(model_cls)</code>","text":"<p>Initialize a query for a model class.</p> <p>Parameters:</p> Name Type Description Default <code>model_cls</code> <code>Type[T]</code> <p>Model class that defines the target table.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = Query(User)\n&gt;&gt;&gt; query.model_cls is User\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.where","title":"<code>where(node)</code>","text":"<p>Add a filter condition to the query</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>QueryNode</code> <p>A QueryNode representing the condition (e.g., User.id == 1).</p> required <p>Returns:</p> Type Description <code>Query[T]</code> <p>The current Query instance for chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.where(User.id == 1)\n&gt;&gt;&gt; isinstance(query, Query)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.order_by","title":"<code>order_by(field, direction='asc')</code>","text":"<p>Add an ordering clause to the query</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Any</code> <p>The field to order by (e.g., User.username).</p> required <code>direction</code> <code>str</code> <p>The direction of the sort (\"asc\" or \"desc\").</p> <code>'asc'</code> <p>Returns:</p> Type Description <code>Query[T]</code> <p>The current Query instance for chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If direction is not \"asc\" or \"desc\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.select().order_by(User.username, \"desc\")\n&gt;&gt;&gt; query.order_by_clause[-1][\"direction\"]\n'desc'\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.limit","title":"<code>limit(value)</code>","text":"<p>Limit the number of records returned</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The maximum number of records to return.</p> required <p>Returns:</p> Type Description <code>Query[T]</code> <p>The current Query instance for chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.select().limit(10)\n&gt;&gt;&gt; query._limit\n10\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.offset","title":"<code>offset(value)</code>","text":"<p>Skip a specific number of records</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The number of records to skip.</p> required <p>Returns:</p> Type Description <code>Query[T]</code> <p>The current Query instance for chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; query = User.select().offset(20)\n&gt;&gt;&gt; query._offset\n20\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.all","title":"<code>all()</code>  <code>async</code>","text":"<p>Return all model instances that match the current query</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A list of model instances.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; users = await User.where(User.active == True).all()\n&gt;&gt;&gt; isinstance(users, list)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.count","title":"<code>count()</code>  <code>async</code>","text":"<p>Return the number of records that match the current query</p> <p>Returns:</p> Type Description <code>int</code> <p>The count of matching records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; total = await User.where(User.active == True).count()\n&gt;&gt;&gt; isinstance(total, int)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.update","title":"<code>update(**fields)</code>  <code>async</code>","text":"<p>Update all records matching the current query</p> <p>Parameters:</p> Name Type Description Default <code>**fields</code> <p>Field names and values to update.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of records updated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; updated = await User.where(User.id == 1).update(name=\"Taylor\")\n&gt;&gt;&gt; isinstance(updated, int)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.first","title":"<code>first()</code>  <code>async</code>","text":"<p>Return the first matching record, or None</p> <p>Returns:</p> Type Description <code>T | None</code> <p>A model instance or None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.select().order_by(User.id).first()\n&gt;&gt;&gt; user is None or isinstance(user, User)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete all records matching the current query</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of records deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; deleted = await User.where(User.disabled == True).delete()\n&gt;&gt;&gt; isinstance(deleted, int)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Return whether at least one record matches the current query</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if records exist, otherwise False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; found = await User.where(User.email == \"a@b.com\").exists()\n&gt;&gt;&gt; isinstance(found, bool)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.add","title":"<code>add(*instances)</code>  <code>async</code>","text":"<p>Add links to a many-to-many relationship</p> <p>Parameters:</p> Name Type Description Default <code>*instances</code> <code>Any</code> <p>Target model instances that provide an <code>id</code> attribute.</p> <code>()</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the query is not bound to a many-to-many context.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.create(email=\"taylor@example.com\")\n&gt;&gt;&gt; admin = await Group.create(name=\"admin\")\n&gt;&gt;&gt; staff = await Group.create(name=\"staff\")\n&gt;&gt;&gt; await user.groups.add(admin, staff)\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.remove","title":"<code>remove(*instances)</code>  <code>async</code>","text":"<p>Remove links from a many-to-many relationship</p> <p>Parameters:</p> Name Type Description Default <code>*instances</code> <code>Any</code> <p>Target model instances that provide an <code>id</code> attribute.</p> <code>()</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the query is not bound to a many-to-many context.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.create(email=\"taylor@example.com\")\n&gt;&gt;&gt; admin = await Group.create(name=\"admin\")\n&gt;&gt;&gt; await user.groups.remove(admin)\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.clear","title":"<code>clear()</code>  <code>async</code>","text":"<p>Clear all links in a many-to-many relationship</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the query is not bound to a many-to-many context.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = await User.create(email=\"taylor@example.com\")\n&gt;&gt;&gt; await user.groups.clear()\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.Query.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a developer-friendly representation of the query</p>"},{"location":"api/query-builder/#ferro.query.builder.BackRelationship","title":"<code>BackRelationship</code>","text":"<p>               Bases: <code>Query[T]</code></p> <p>Represent reverse relationship queries with Query typing support</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class User(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     name: str\n...     posts: BackRelationship[list[\"Post\"]] = None\n</code></pre> <pre><code>&gt;&gt;&gt; class Post(Model):\n...     id: Annotated[int, FerroField(primary_key=True)]\n...     title: str\n...     user: Annotated[User, ForeignKey(related_name=\"posts\")]\n</code></pre> <pre><code>&gt;&gt;&gt; user = await User.get(1)\n&gt;&gt;&gt; posts = await user.posts.all()\n&gt;&gt;&gt; isinstance(posts, list)\nTrue\n</code></pre>"},{"location":"api/query-builder/#ferro.query.builder.BackRelationship-functions","title":"Functions","text":""},{"location":"api/query-builder/#ferro.query.builder.BackRelationship.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type, _handler)</code>  <code>classmethod</code>","text":"<p>Allow pydantic-core to treat relationships as arbitrary runtime values</p>"}]}